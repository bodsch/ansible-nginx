#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# (c) 2021-2022, Bodo Schulz <bodo@boone-schulz.de>
# Apache (see LICENSE or https://opensource.org/licenses/Apache-2.0)

from __future__ import absolute_import, division, print_function
import os
import hashlib
import json
import time

from ansible.module_utils.basic import AnsibleModule

TPL_SSL = """# generated by ansible

{% for key, value in item.items() %}
    {% if key == "ssl_protocols" %}
{{ key.ljust(24) }}  {{ value | join(' ') }};
    {% elif (value is sameas true or value is sameas false) %}
{{ key.ljust(24) }}  {{ 'on' if value else 'off' }};
    {% else %}
{{ key.ljust(24) }}  {{ value }};
    {% endif %}
{% endfor %}

"""

TPL_CIPHERS = """# generated by ansible

ssl_ciphers  {{ item }};

"""


class Checksum():
    """
        temporary
        in the future, i will use the bodsch.core collection
    """

    def __init__(self, module):
        self.module = module

    def checksum(self, plaintext, algorithm="sha256"):
        """
            compute checksum for plaintext
        """
        # self.module.log(f"{type(plaintext)}")
        _data = self._harmonize_data(plaintext)

        # self.module.log(f"{_data}")
        # self.module.log(f"{type(_data)}")

        checksum = hashlib.new(algorithm)
        checksum.update(_data.encode('utf-8'))

        return checksum.hexdigest()

    def validate(self, checksum_file, data=None):
        """
        """
        # self.module.log(msg=f" - checksum_file '{checksum_file}'")
        old_checksum = None

        if not isinstance(data, str) or not isinstance(data, dict):
            if not data and os.path.exists(checksum_file):
                os.remove(checksum_file)

        if os.path.exists(checksum_file):
            with open(checksum_file, "r") as f:
                old_checksum = f.readlines()[0]

        _data = self._harmonize_data(data)

        checksum = self.checksum(_data)
        changed = not (old_checksum == checksum)

        return (changed, checksum, old_checksum)

    def checksum_from_file(self, path, read_chunksize=65536, algorithm='sha256'):
        """
            Compute checksum of a file's contents.

        :param path: Path to the file
        :param read_chunksize: Maximum number of bytes to be read from the file
                                at once. Default is 65536 bytes or 64KB
        :param algorithm: The hash algorithm name to use. For example, 'md5',
                                'sha256', 'sha512' and so on. Default is 'sha256'. Refer to
                                hashlib.algorithms_available for available algorithms
        :return: Hex digest string of the checksum
        """

        if os.path.isfile(path):
            checksum = hashlib.new(algorithm)  # Raises appropriate exceptions.
            with open(path, 'rb') as f:
                for chunk in iter(lambda: f.read(read_chunksize), b''):
                    checksum.update(chunk)
                    # Release greenthread, if greenthreads are not used it is a noop.
                    time.sleep(0)

            return checksum.hexdigest()
        else:
            return None

    def write_checksum(self, checksum_file, checksum=None):
        """
        """
        with open(checksum_file, "w") as f:
            f.write(checksum)

    def _harmonize_data(self, data):
        """
        """
        if isinstance(data, dict):
            _data = json.dumps(data, sort_keys=True)
        elif isinstance(data, list):
            _data = ''.join(str(x) for x in data)
        elif isinstance(data, str):
            _data = data
        else:
            _data = data.copy()

        return _data


class NginxSsl(object):
    """
    """

    def __init__(self, module):
        """
        """
        self.module = module
        self.ssl_config = module.params.get("config")
        self.dest = module.params.get("dest")
        self.cache_directory = "/var/cache/ansible/nginx"

    def run(self):
        """
        """
        result_state = []

        self.checksum = Checksum(self.module)

        self.__create_directory(self.cache_directory)
        checksum_file = os.path.join(self.cache_directory, "ssl_config")

        changed, checksum, old_checksum = self.checksum.validate(
            checksum_file=checksum_file,
            data=self.ssl_config
        )

        if not changed:
            return dict(
                changed = False,
                msg = "The ssl configuration has not been changed."
            )

        if isinstance(self.ssl_config, dict):

            ssl_config = self.ssl_config.copy()
            # remove our 'enabled' value
            _ = ssl_config.pop("enabled")

            ssl_ciphers = ssl_config.get("ssl_ciphers", {})
            _ = ssl_config.pop("ssl_ciphers")

            file_name = "ssl.conf"

            _failed, _changed, _msg = self._write_template(
                "ssl",
                os.path.join(self.dest, file_name),
                ssl_config
            )

            res = {}
            res[file_name] = dict(
                failed=_failed,
                changed=_changed,
                msg=_msg
            )
            result_state.append(res)

            for key, values in ssl_ciphers.items():
                res = {}
                file_name = f"ssl_{key}.conf"
                _failed, _changed, _msg = self._write_template(
                    "ssl_ciphers",
                    os.path.join(self.dest, file_name),
                    values
                )

                res[file_name] = dict(
                    failed=_failed,
                    changed=_changed,
                    msg=_msg
                )

                result_state.append(res)

        # define changed for the running tasks
        # migrate a list of dict into dict
        combined_d = {key: value for d in result_state for key, value in d.items()}
        # find all changed and define our variable
        changed = {k: v for k, v in combined_d.items() if isinstance(v, dict) if v.get('changed')}
        failed = {k: v for k, v in combined_d.items() if isinstance(v, dict) if v.get('failed')}

        _changed = (len(changed) > 0)
        _failed = (len(failed) > 0)

        result = dict(
            failed = _failed,
            changed = _changed,
            result = result_state
        )

        return result

    def _write_template(self, type, file_name, data):
        """
        """
        if isinstance(data, dict):
            """
                sort data
            """
            data = json.dumps(data, sort_keys=True)
            if isinstance(data, str):
                data = json.loads(data)

        if isinstance(data, list):
            data = ":".join(data)

        checksum_file = os.path.join(self.cache_directory, f"{os.path.basename(file_name)}.checksum")

        changed, checksum, old_checksum = self.checksum.validate(
            checksum_file=checksum_file,
            data=data
        )

        if not changed:
            return False, False, "The configuration file has not been changed."

        from jinja2 import Template

        if type == "ssl":
            tpl = TPL_SSL
        else:
            tpl = TPL_CIPHERS

        tm = Template(tpl, trim_blocks=True, lstrip_blocks = True)
        d = tm.render(item=data)

        with open(file_name, "w") as f:
            f.write(d)

        self.checksum.write_checksum(
            checksum_file=checksum_file,
            checksum=checksum
        )

        return False, True, "The configuration file was written successfully."

    def __create_directory(self, dir):
        """
            temporary
            in the future, i will use the bodsch.core collection
        """
        try:
            os.makedirs(dir, exist_ok=True)
        except FileExistsError:
            pass

        if os.path.isdir(dir):
            return True
        else:
            return False

# ===========================================
# Module execution.


def main():

    args = dict(
        config=dict(
            required=True,
            type="dict"
        ),
        dest = dict(
            required=False,
            default = "/etc/nginx/conf.d"
        )
    )

    module = AnsibleModule(
        argument_spec=args,
        supports_check_mode=True,
    )

    p = NginxSsl(module)
    result = p.run()

    # module.log(msg="= result: {}".format(result))
    module.exit_json(**result)


if __name__ == '__main__':
    main()
